#use "code-gen.ml";;

let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));;

let primitive_names_to_labels = 
  ["boolean?", "is_boolean"; "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
   "null?", "is_null"; "char?", "is_char"; "string?", "is_string";
   "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
   "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
   "symbol->string", "symbol_to_string"; 
   "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ";
    "car", "car"; "cdr", "cdr"; "set-car!","set_car";"set-cdr!","set_cdr"; "cons", "cons";"apply","apply"
(* you can add yours here *)];;

let make_prologue consts_tbl fvars_tbl =
  let make_primitive_closure (prim, label) =
    (* Adapt the addressing here to your fvar addressing scheme:
       This imlementation assumes fvars are offset from the base label fvar_tbl *)
"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov [fvar_tbl+8*" ^  (string_of_int (List.assoc prim fvars_tbl)) ^ "], rax" in
  let constant_bytes (c, (a, s)) = s in
"
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
" ^ (String.concat "\n" (List.map constant_bytes consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc Void consts_tbl))) ^ "
%define SOB_NIL_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc (Sexpr Nil) consts_tbl))) ^ "
%define SOB_FALSE_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc (Sexpr (Bool false)) consts_tbl))) ^ "
%define SOB_TRUE_ADDRESS const_tbl+" ^ (string_of_int  (fst (List.assoc (Sexpr (Bool true)) consts_tbl))) ^ "

fvar_tbl:
" ^
  (* This line should be adapted to your fvar-addressing scheme. 
     I.e., if you use direct labeling, you should output them here. *)
  (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "

global main
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp
    mov rbp,rsp

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
" ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ "

user_code_fragment:
;;; The code you compiled will be catenated here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.

";;

(* You may populate this variable with a string containing the epilogue.
   You may load it from a file, you may write it here inline, 
   you may just add things to prims.s (which gets catenated with the epilogue variable).
   Whatever floats your boat. You just have to make sure all the required
   primitive procedures are implemented and included in the output assembly. *)
let epilogue = "

 car: 
    push rbp
    mov rbp, rsp

    mov rax, PVAR(0)
    mov rax, qword [rax + 1]

    leave
    ret


cdr: 
    push rbp
    mov rbp, rsp

    mov rax, PVAR(0)
    mov rax, qword [rax + 9]

    leave
    ret

set_car: 
    push rbp
    mov rbp, rsp

    mov r8, PVAR(0)
    mov r9, PVAR(1)
    mov qword [r8 + 1], r9 
    mov rax, SOB_VOID_ADDRESS
    
    leave
    ret

set_cdr: 
    push rbp
    mov rbp, rsp

    mov rax, PVAR(0)
    mov r10, PVAR(1)
    mov qword [rax + 9], r10
    mov rax, SOB_VOID_ADDRESS

    leave
    ret

cons:
    push rbp
    mov rbp, rsp

    push r11
    push r12
    mov r11, PVAR(0)
    mov r12, PVAR(1)
    MAKE_PAIR (rax, r11, r12)  
    pop r12
    pop r11
    
    leave
    ret


apply:
    push rbp
    mov rbp, rsp
    mov r10, 3
    shl r10, 3
    mov r8, qword [rbp + r10] 
    mov r10, r8 
    add r10 , 4 
    shl r10, 3 
    add r10 ,rbp 
    push qword [r10] 
    mov r13, r10
    sub r13 , 8       
    mov r13, qword [r13]
    mov rcx,0 
    mov r9 , SOB_NIL_ADDRESS
    cmp byte [r13], 2 
    je endChangeLst

    changeLst:

        inc rcx
        mov r10, r13
        add r10, 1
        mov r12, qword [r10] 
        mov r15, r9 
        MAKE_PAIR (r9, r12, r15) 
        mov r10, r13
        add r10, 9
        mov r13, qword [r10] 
        cmp byte [r13], T_NIL 
        jne changeLst
    
    endChangeLst:

    cmp byte [r9], 2
    je endAppendLst

    appendReverse:

        mov r10, r9
        add r10, 1
        mov r12, qword [r10] 
        push r12  
        mov r10, r9
        add r10, 9
        mov r9, qword [r10] 
        cmp byte [r9], 2
        jne appendReverse
    
    endAppendLst:

    mov r10, r8
    add r10, 3
    lea r9, [r10]
    shl r9, 3
    add r9, rbp ; r9<- start of the params list
    mov r12, 8 
    mov r10, r8
    sub r10, 2 ; n-2
    cmp r10, 0
    je endParams

    params:
        mov r15 ,r9
        sub r15, r12
        push qword [r15]
        add r12, 8
        dec r10
        cmp r10, 0
        jne params
    endParams:

    mov r10, r8
    sub r10, 2 
    add r10,rcx 
    push r10
    mov r13, PVAR(0)
    push qword [r13 + 1]  
    push qword [rbp + 8 * 1]
    add r10, 4 
	push rax
	mov r14, [rbp]
	mov r9, qword [rbp + 8*3]
	mov rax, [rbp+8*3]
	add rax, 5
	mov rcx, 1	
    cmp r10, rcx
	jl endMoveLoop

    moveLoop:
		dec rax
		mov r15, rcx
		shl r15, 3
		mov rdx, rbp
		sub rdx, r15 
		mov r11, qword [rdx]
		mov [rbp + 8*rax],r11 
		inc rcx
		cmp r10, rcx
		jge moveLoop
	endMoveLoop:
	pop rax
	add r9, 5
	shl r9, 3
	add rsp, r9
	mov rbp, r14
    mov r9, r13
    add r9, 9
    jmp qword [r9]

    leave
    ret
";;

exception X_missing_input_file;;

try
  let infile = Sys.argv.(1) in
  let code =  (file_to_string "stdlib.scm") ^   (file_to_string infile) in
  let asts = string_to_asts code in
  let consts_tbl = Code_Gen.make_consts_tbl asts in
  let fvars_tbl = Code_Gen.make_fvars_tbl asts in
  let generate = Code_Gen.generate consts_tbl fvars_tbl in
  let code_fragment = String.concat "\n\n"
                        (List.map
                           (fun ast -> (generate ast) ^ "\n\tcall write_sob_if_not_void")
                           asts) in
  (* clean_exit contains instructions to clean the dummy stack
     and return exit code 0 ("all's well") from procedure main. *)
  let clean_exit = "\n\n\tmov rax, 0\n\tadd rsp, 4*8\n\tpop rbp\n\tret\n\n" in
  let provided_primitives = file_to_string "prims.s" in
                   
  print_string ((make_prologue consts_tbl fvars_tbl)  ^
                  code_fragment ^ clean_exit ^
                    provided_primitives ^ "\n" ^ epilogue)

with Invalid_argument(x) -> raise X_missing_input_file;;
